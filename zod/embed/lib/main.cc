int main(int argc, char** argv) {
  if (argc < 2) {
    eprintln("filepath not provided");
  }

  auto path = fs::path(argv[1]);
  auto out = fs::path(argc == 2 ? "." : argv[2]);
  auto name = path.stem();
  auto outpath = out / fs::path(name).replace_extension(".c");

  if (not fs::exists(path)) {
    eprintln("`{}` does not exist", path.string());
  }

  FILE* f = std::fopen(path.c_str(), "r");
  if (not f) {
    eprintln("cannot open `{}`\n  {}", path.c_str(), std::strerror(errno));
  }

  if (std::fseek(f, 0L, SEEK_END)) {
    eprintln("{}", std::strerror(errno));
  }

  auto file_size = std::ftell(f);
  if (file_size < 0) {
    eprintln("cannot get file size\n  {}", std::strerror(errno));
  }

  std::rewind(f);
  auto size = zod::usize(file_size);
  auto content = new char[size];
  auto read_bytes = std::fread(content, 1, size, f);
  std::fclose(f);
  if (read_bytes != size) {
    int e = std::feof(f);
    if (e) {
      eprintln("unexpected end of file");
    } else {
      e = std::ferror(f);
      eprintln("cannot read file\n  {}", std::strerror(e));
    }
  }

  std::printf("/// Generated by `embed`\n");
  int col = std::printf("const char* %s_src = { ", name.string().c_str());
  for (zod::usize i = 0; i < size; ++i) {
    col += std::printf("%d", content[i]);
    col += std::printf(",");
    if (col > 50 and i != size - 1) {
      std::printf("\n  ");
      col = 2;
    } else {
      col += std::printf(" ");
    }
  }
  std::printf("\n};\n");

  delete[] content;
}
