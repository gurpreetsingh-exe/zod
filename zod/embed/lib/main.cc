int main(int argc, char** argv) {
  if (argc < 2) {
    eprintln("filepath not provided");
  }

  auto path = fs::path(argv[1]);
  auto out = fs::path(argc == 2 ? "." : argv[2]);
  auto name = path.stem().string();
  for (zod::usize i = 0; i < name.size(); ++i) {
    if (name[i] == '.') {
      name[i] = '_';
    }
  }
  auto outpath = out / fs::path(name).replace_extension(".c");

  if (not fs::exists(path)) {
    eprintln("`{}` does not exist", path.string());
  }

  FILE* f = std::fopen(path.c_str(), "r");
  if (not f) {
    eprintln("cannot open `{}`\n  {}", path.c_str(), std::strerror(errno));
  }

  if (std::fseek(f, 0L, SEEK_END)) {
    eprintln("{}", std::strerror(errno));
  }

  auto file_size = std::ftell(f);
  if (file_size < 0) {
    eprintln("cannot get file size\n  {}", std::strerror(errno));
  }

  std::rewind(f);
  auto size = zod::usize(file_size);
  auto content = new char[size + 1];
  std::memset(content, 0, size + 1);
  auto read_bytes = std::fread(content, 1, size, f);
  std::fclose(f);
  if (read_bytes != size) {
    int e = std::feof(f);
    if (e) {
      eprintln("unexpected end of file");
    } else {
      e = std::ferror(f);
      eprintln("cannot read file\n  {}", std::strerror(e));
    }
  }

  std::printf("/// Generated by `embed`\n");
  std::printf("const char* g_%s_src = R\"(\n%s)\";\n", name.c_str(), content);

  delete[] content;
}
